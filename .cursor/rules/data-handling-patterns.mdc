# Data Handling Patterns

## Database Query Organization

All database operations must be organized into reusable helper functions within the `src/db/queries/` directory. This promotes code reusability, testability, and separation of concerns.

## Directory Structure

```
src/
  db/
    queries/
      decks.ts       # Deck-related database operations
      cards.ts       # Card-related database operations
      users.ts       # User-related database operations (if needed)
      index.ts       # Re-export all query functions
```

## Server Components for Data Retrieval

Server Components should use query helper functions for data retrieval, never perform database operations directly:

**Example:**
```typescript
// ✅ Correct - Server Component using query helpers
import { getDecksByUserId } from "@/db/queries/decks";

export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  const decks = await getDecksByUserId(userId);
  return <DecksList decks={decks} />;
}

// ❌ Incorrect - Direct database operations in components
import { db } from "@/lib/db";
import { decksTable } from "@/db/schema";

export default async function DecksPage() {
  const { userId } = await auth();
  if (!userId) redirect("/");
  
  const decks = await db.select().from(decksTable).where(eq(decksTable.userId, userId));
  return <DecksList decks={decks} />;
}
```

## Server Actions for Data Mutations

Server Actions should use mutation helper functions, never perform database operations directly:

**Example:**
```typescript
// ✅ Correct - Server Action using mutation helpers
import { createDeck, updateDeck, deleteDeck } from "@/db/queries/decks";

"use server";
export async function createDeckAction(data: CreateDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validatedData = createDeckSchema.parse(data);
  return await createDeck({ ...validatedData, userId });
}

// ❌ Incorrect - Direct database operations in server actions
import { db } from "@/lib/db";
import { decksTable } from "@/db/schema";

"use server";
export async function createDeckAction(data: CreateDeckInput) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");
  
  const validatedData = createDeckSchema.parse(data);
  await db.insert(decksTable).values({ ...validatedData, userId });
}
```

## Query Helper Function Patterns

### Query Functions (Read Operations)

```typescript
// src/db/queries/decks.ts
import { db } from "@/lib/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";

export async function getDecksByUserId(userId: string) {
  return await db.select().from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.updatedAt));
}

export async function getDeckWithCards(deckId: number, userId: string) {
  const deck = await db.select().from(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
    .limit(1);
    
  if (!deck.length) return null;
  
  const cards = await db.select().from(cardsTable)
    .where(eq(cardsTable.deckId, deckId))
    .orderBy(cardsTable.order);
    
  return { ...deck[0], cards };
}

export async function getDeckById(deckId: number, userId: string) {
  const result = await db.select().from(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
    .limit(1);
    
  return result[0] || null;
}
```

### Mutation Functions (Write Operations)

```typescript
// src/db/queries/decks.ts (continued)
import type { InsertDeck, UpdateDeck } from "@/db/schema";

export async function createDeck(data: InsertDeck) {
  const [newDeck] = await db.insert(decksTable).values({
    ...data,
    createdAt: new Date(),
    updatedAt: new Date(),
  }).returning();
  
  return newDeck;
}

export async function updateDeck(deckId: number, userId: string, data: Partial<UpdateDeck>) {
  const [updatedDeck] = await db.update(decksTable)
    .set({ ...data, updatedAt: new Date() })
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
    .returning();
    
  return updatedDeck;
}

export async function deleteDeck(deckId: number, userId: string) {
  const [deletedDeck] = await db.delete(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
    .returning();
    
  return deletedDeck;
}
```

## Index File for Re-exports

```typescript
// src/db/queries/index.ts
export * from "./decks";
export * from "./cards";
export * from "./users";
```

## Zod Validation Requirements

All query helper functions must validate their input using Zod schemas when accepting user data:

1. **Input Validation**: Validate all user-provided data before database operations
2. **TypeScript Integration**: Use Zod schemas to generate TypeScript types
3. **Consistent Error Handling**: Use consistent error patterns across all queries

**Example:**
```typescript
import { z } from "zod";

const createDeckSchema = z.object({
  title: z.string().min(1, "Title is required").max(100),
  description: z.string().max(500).optional(),
});

const updateDeckSchema = createDeckSchema.partial();

export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

export async function createDeck(input: CreateDeckInput & { userId: string }) {
  const validatedData = createDeckSchema.parse(input);
  // ... database operation
}
```

## Error Handling Pattern

All query functions must implement consistent error handling:

```typescript
export async function getDeckById(deckId: number, userId: string) {
  try {
    const result = await db.select().from(decksTable)
      .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
      .limit(1);
      
    return result[0] || null;
  } catch (error) {
    console.error("Error fetching deck:", error);
    throw new Error("Failed to fetch deck");
  }
}
```

## Security Requirements

All query functions MUST enforce data isolation:

1. **User ID Validation**: Every query that accesses user-specific data must include userId in the WHERE clause
2. **Resource Ownership**: Always verify the user owns the resource before returning or modifying it
3. **Authorization**: Never trust client-provided user IDs - always get userId from authentication

## Key Rules Summary

1. **Query Organization**: All database operations must be in `src/db/queries/` helper functions
2. **Separation of Concerns**: Server Components and Server Actions should only call query helpers
3. **Data Isolation**: Every query must enforce user-specific data access
4. **Validation**: Use Zod schemas for all user input validation
5. **Error Handling**: Implement consistent error handling patterns
6. **TypeScript**: Leverage full TypeScript integration with Drizzle and Zod
7. **No Direct DB Operations**: Never perform database operations directly in components or actions

## Migration from Direct DB Operations

When refactoring existing code:

1. **Identify** all direct database operations in components and actions
2. **Extract** these operations into appropriately named query helper functions
3. **Move** the functions to the correct file in `src/db/queries/`
4. **Replace** direct operations with calls to the helper functions
5. **Test** that all functionality works correctly after refactoring

This pattern ensures better code organization, reusability, testability, and maintains the security requirements for user data isolation.